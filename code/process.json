[{
  "id" : "m3bqdb",
  "name" : "data_sentinel1",
  "description" : null,
  "code" : "# Data preparation for Sentinel 1\n\nimport geopandas as gpd\nimport geoviews as gv\nimport holoviews as hv\nimport hvplot.pandas\nimport hvplot.xarray\nimport panel as pn\nimport intake\nimport numpy as np\nimport os\nimport pandas as pd\nimport rasterio\nimport rioxarray\nimport s3fs \nimport xarray as xr\nhv.extension('bokeh')\n\nprint(\"prepare Sentinel 1 into .csv\")\n\n# GDAL environment variables to efficiently read remote data\nos.environ['GDAL_DISABLE_READDIR_ON_OPEN']='EMPTY_DIR' #This is KEY! otherwise we send a bunch of HTTP GET requests to test for common sidecar metadata\nos.environ['AWS_NO_SIGN_REQUEST']='YES' #Since this is a public bucket, we don't need authentication\nos.environ['GDAL_MAX_RAW_BLOCK_CACHE_SIZE']='200000000'  #200MB: Default is 10 MB limit in the GeoTIFF driver for range request merging.\n\n# Data is stored in a public S3 Bucket\nurl = 's3://sentinel-s1-rtc-indigo/tiles/RTC/1/IW/12/S/YJ/2016/S1B_20161121_12SYJ_ASC/Gamma0_VV.tif'\n\n# These Cloud-Optimized-Geotiff (COG) files have 'overviews', low-resolution copies for quick visualization\nda = rioxarray.open_rasterio(url, overview_level=3).squeeze('band')\n\nzone = 12\nlatLabel = 'S'\nsquare = 'YJ'\nyear = '202*' #>=2020\ndate = '*' #all acquisitions\npolarization = 'VV'\ns3Path = f's3://sentinel-s1-rtc-indigo/tiles/RTC/1/IW/{zone}/{latLabel}/{square}/{year}/{date}/Gamma0_{polarization}.tif'\n\n# Find imagery according to S3 path pattern\ns3 = s3fs.S3FileSystem(anon=True)\nkeys = s3.glob(s3Path[5:]) #strip s3://\nprint(f'Located {len(keys)} images matching {s3Path}:')\n\nvrtName = f'stack{zone}{latLabel}{square}.vrt'\nif not os.path.exists(vrtName):\n    with open('s3paths.txt', 'w') as f:\n        for key in keys:\n            f.write(\"/vsis3/%s\\n\" % key)\n    print(\"current working dir: \", os.getcwd())\n    cmd = f'gdalbuildvrt -overwrite -separate -input_file_list s3paths.txt {os.getcwd()}/{vrtName}'\n    print(cmd)\n    os.system(cmd)\n\n# Load a time series we created a VRT with GDAL to facilitate this step\nda3 = rioxarray.open_rasterio(os.getcwd() + \"/\" + vrtName, overview_level=3, chunks='auto')\n\n# Need to add time coordinates to this data\ndatetimes = [pd.to_datetime(x[55:63]) for x in keys]\n    \n# add new coordinate to existing dimension \nda = da3.assign_coords(time=('band', datetimes))\n# make 'time' active coordinate instead of integer band\nda = da.swap_dims({'band':'time'})\n# Name the dataset (helpful for hvplot calls later on)\nda.name = 'Gamma0VV'\n\n#use a small bounding box over grand mesa (UTM coordinates)\nxmin,xmax,ymin,ymax = [739186, 742748, 4.325443e+06, 4.327356e+06]\ndaT = da.sel(x=slice(xmin, xmax), \n             y=slice(ymax, ymin))\n\n# NOTE: this can take a while on slow internet connections, we're reading over 100 images!\nall_points = daT.where(daT!=0).hvplot.scatter('time', groupby=[], dynspread=True, datashade=True) \nmean_trend = daT.where(daT!=0, drop=True).mean(dim=['x','y']).hvplot.line(title='North Grand Mesa', color='red')\n\npath = '/tmp/tutorial-data/sar/sentinel1/S1AA_20201030T131820_20201111T131820_VVP012_INT80_G_ueF_EBD2/S1AA_20201030T131820_20201111T131820_VVP012_INT80_G_ueF_EBD2_unw_phase.tif'\nda = rioxarray.open_rasterio(path, masked=True).squeeze('band')\n\n\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "78vedq",
  "name" : "data_sentinel2",
  "description" : "python",
  "code" : "# Data Preparation for Sentinel 2\n\nprint(\"Prepare sentinel 2 into .csv\")\n\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "ob2m37",
  "name" : "data_modis",
  "description" : "python",
  "code" : "# Data Preparation MODIS\n\nprint(\"Prepare MODIS into .csv\")\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "mxpyqt",
  "name" : "model_creation_lstm",
  "description" : "python",
  "code" : "# Create LSTM model\n\nprint(\"Create LSTM\")\n\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "c2xkhz",
  "name" : "model_creation_rf",
  "description" : null,
  "code" : "# Random Forest model creation and save to file\n\nfrom sklearn.ensemble import RandomForestRegressor\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn import metrics \nfrom sklearn import tree\nimport joblib\nimport os\nfrom pathlib import Path\nimport json\nimport geopandas as gpd\nimport geojson\nimport os.path\nimport math\nfrom sklearn.model_selection import RandomizedSearchCV\n\n#pd.set_option('display.max_columns', None)\n\n# read the grid geometry file\nhomedir = os.path.expanduser('~')\nprint(homedir)\ngithub_dir = f\"{homedir}/Documents/GitHub/SnowCast\"\nmodis_ready_file = f\"{github_dir}/data/ready_for_training/modis_train_ready.csv\"\nmodis_ready_pd = pd.read_csv(modis_ready_file, header=0, index_col=0)\n\npd_to_clean = modis_ready_pd[[\"year\", \"m\", \"doy\", \"ndsi\", \"swe\"]].dropna()\n\nall_features = pd_to_clean[[\"year\", \"m\", \"doy\", \"ndsi\"]].to_numpy()\nall_labels = pd_to_clean[[\"swe\"]].to_numpy().ravel()\n\ntrain_features, test_features, train_labels, test_labels = train_test_split(all_features, all_labels, test_size=0.20, random_state=42)\n\nprint(train_features.shape)\nprint(train_labels.shape)\nprint(test_features.shape)\nprint(test_labels.shape)\n\nprint(\"==> create random forest model\")\n\n# Number of trees in random forest\nn_estimators = [int(x) for x in np.linspace(start = 200, stop = 2000, num = 10)]\n# Number of features to consider at every split\nmax_features = ['auto', 'sqrt']\n# Maximum number of levels in tree\nmax_depth = [int(x) for x in np.linspace(10, 110, num = 11)]\nmax_depth.append(None)\n# Minimum number of samples required to split a node\nmin_samples_split = [2, 5, 10]\n# Minimum number of samples required at each leaf node\nmin_samples_leaf = [1, 2, 4]\n# Method of selecting samples for training each tree\nbootstrap = [True, False]\n# Create the random grid\nrandom_grid = {'n_estimators': n_estimators,\n               'max_features': max_features,\n               'max_depth': max_depth,\n               'min_samples_split': min_samples_split,\n               'min_samples_leaf': min_samples_leaf,\n               'bootstrap': bootstrap}\nprint(random_grid)\n\nrandomForestregModel = RandomForestRegressor()\n# Random search of parameters, using 3 fold cross validation, \n# search across 100 different combinations, and use all available cores\nrf_random = RandomizedSearchCV(estimator = randomForestregModel, param_distributions = random_grid, n_iter = 100, cv = 3, verbose=2, random_state=42, n_jobs = -1)\n\n# Fit the random search model\nrf_random.fit(train_features, train_labels)\n\nprint(\"rf_random.best_params_: \", rf_random.best_params_)\n\ndef evaluate(model, test_features, y_test, model_name):\n    y_predicted = model.predict(test_features)\n    mae = metrics.mean_absolute_error(y_test, y_predicted)\n    mse = metrics.mean_squared_error(y_test, y_predicted)\n    r2 = metrics.r2_score(y_test, y_predicted)\n    rmse = math.sqrt(mse)\n\n    print(\"The model performance for testing set\")\n    print(\"--------------------------------------\")\n    print('MAE is {}'.format(mae))\n    print('MSE is {}'.format(mse))\n    print('R2 score is {}'.format(r2))\n    print('RMSE is {}'.format(rmse))\n    \n    return r2\n\nbase_model = RandomForestRegressor(n_estimators = 10, random_state = 42)\nbase_model.fit(train_features, train_labels)\nbase_accuracy = evaluate(base_model, test_features, test_labels, \"Base Model\")\n\nbest_random = rf_random.best_estimator_\nrandom_accuracy = evaluate(best_random, test_features, test_labels, \"Optimized\")\n\nprint('Improvement of {:0.2f}%.'.format( 100 * (random_accuracy - base_accuracy) / base_accuracy))\n\nos.makedirs(f\"{github_dir}/model/\", exist_ok=True)\n# save\njoblib.dump(base_model, f\"{github_dir}/model/wormhole_random_forest_basic_v2.joblib\")\njoblib.dump(best_random, f\"{github_dir}/model/wormhole_random_forest_v2.joblib\")\nprint(\"wormhole_random_forest is saved to file\")\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "rauqsh",
  "name" : "model_creation_ghostnet",
  "description" : "python",
  "code" : "# GhostNet\n\nprint(\"Create GhostNet\")\n\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "mi3e5n",
  "name" : "model_comparison",
  "description" : "python",
  "code" : "# Find the best model\n\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "u7xh2p",
  "name" : "data_integration",
  "description" : null,
  "code" : "# Integrate all the datasets into one training dataset\nimport json\nimport pandas as pd\nimport ee\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport os\nimport geopandas as gpd\nimport geojson\nimport numpy as np\nimport os.path\nimport math\nfrom datetime import datetime\n\n\nprint(\"integrating datasets into one dataset\")\n#pd.set_option('display.max_columns', None)\n\n# read the grid geometry file\nhomedir = os.path.expanduser('~')\nprint(homedir)\ngithub_dir = f\"{homedir}/Documents/GitHub/SnowCast\"\n# read grid cell\ngridcells_file = f\"{github_dir}/data/snowcast_provided/grid_cells.geojson\"\nmodel_dir = f\"{github_dir}/model/\"\ntraining_feature_file = f\"{github_dir}/data/snowcast_provided/ground_measures_train_features.csv\"\ntesting_feature_file = f\"{github_dir}/data/snowcast_provided/ground_measures_test_features.csv\"\ntrain_labels_file = f\"{github_dir}/data/snowcast_provided/train_labels.csv\"\nground_measure_metadata_file = f\"{github_dir}/data/snowcast_provided/ground_measures_metadata.csv\"\nstation_cell_mapper_file = f\"{github_dir}/data/ready_for_training/station_cell_mapping.csv\"\n\n#example_mod_file = f\"{github_dir}/data/modis/mod10a1_ndsi_f191fe19-0e81-4bc9-9980-29738a05a49b.csv\"\n\n\ntraining_feature_pd = pd.read_csv(training_feature_file, header=0, index_col=0)\ntesting_feature_pd = pd.read_csv(testing_feature_file, header=0, index_col=0)\ntrain_labels_pd = pd.read_csv(train_labels_file, header=0, index_col=0)\n#print(training_feature_pd.head())\n\nstation_cell_mapper_pd = pd.read_csv(station_cell_mapper_file, header=0, index_col=0)\n#print(station_cell_mapper_pd.head())\n\n#example_mod_pd = pd.read_csv(example_mod_file, header=0, index_col=0)\n#print(example_mod_pd.shape)\n\n\ndef integrate_modis():\n  \"\"\"\n  Integrate all MODIS data into mod_all.csv\n  \"\"\"\n  dates = pd.date_range(start='1/1/2013', end='12/31/2021', freq='D').astype(str)\n  mod_all_df = pd.DataFrame(columns=[\"date\"])\n  mod_all_df['date'] = dates\n  all_mod_file = f\"{github_dir}/data/ready_for_training/modis_all.csv\"\n  #print(mod_all_df.head())\n  for ind in station_cell_mapper_pd.index:\n    current_cell_id = station_cell_mapper_pd[\"cell_id\"][ind]\n    print(current_cell_id)\n    mod_single_file = f\"{github_dir}/data/modis/mod10a1_ndsi_{current_cell_id}.csv\"\n    if os.path.isfile(mod_single_file):\n      mod_single_pd = pd.read_csv(mod_single_file, header=0)\n      mod_single_pd = mod_single_pd[[\"date\", \"mod10a1_ndsi\"]]\n      mod_single_pd = mod_single_pd.rename(columns={\"mod10a1_ndsi\": current_cell_id})\n      mod_single_pd['date'] = pd.to_datetime(mod_single_pd['date']).astype(str)\n      print(mod_all_df.shape)\n      mod_all_df = pd.merge(mod_all_df, mod_single_pd, how='left', on=\"date\")\n  mod_all_df.to_csv(all_mod_file)\n\n  \ndef integrate_sentinel1():\n  \"\"\"\n  Integrate all Sentinel 1 data into sentinel1_all.csv\n  \"\"\"\n  dates = pd.date_range(start='1/1/2013', end='12/31/2021', freq='D').astype(str)\n  sentinel1_all_df = pd.DataFrame(columns=[\"date\"])\n  sentinel1_all_df['date'] = dates\n  #print(mod_all_df.head())\n  all_sentinel1_file = f\"{github_dir}/data/ready_for_training/sentinel1_all.csv\"\n\n  def getDateStr(x):\n    return x.split(\" \")[0]\n\n  for ind in station_cell_mapper_pd.index:\n    current_cell_id = station_cell_mapper_pd[\"cell_id\"][ind]\n    print(current_cell_id)\n    sentinel1_single_file = f\"{github_dir}/data/sentinel1/s1_grd_vv_{current_cell_id}.csv\"\n    if os.path.isfile(sentinel1_single_file) and current_cell_id not in sentinel1_all_df :\n      sentinel1_single_pd = pd.read_csv(sentinel1_single_file, header=0)\n      sentinel1_single_pd = sentinel1_single_pd[[\"date\", \"s1_grd_vv\"]]\n      sentinel1_single_pd = sentinel1_single_pd.rename(columns={\"s1_grd_vv\": current_cell_id})\n      #sentinel1_single_pd['date'] = sentinel1_single_pd['date'].astype('datetime64[ns]')\n      sentinel1_single_pd['date'] = pd.to_datetime(sentinel1_single_pd['date']).dt.round(\"D\").astype(str)\n      print(\"sentinel1_single_pd: \", sentinel1_single_pd.head())\n      print(\"sentinel1_single_pd check value: \", sentinel1_single_pd[sentinel1_single_pd[\"date\"]==\"2015-04-01\"])\n      sentinel1_single_pd = sentinel1_single_pd.drop_duplicates(subset=['date'], keep='first') # this will remove all the other values of the same day\n      \n      sentinel1_all_df = pd.merge(sentinel1_all_df, sentinel1_single_pd, how='left', on=\"date\")\n      print(\"sentinel1_all_df check value: \", sentinel1_all_df[sentinel1_all_df[\"date\"]==\"2015-04-01\"])\n      print(\"sentinel1_all_df: \", sentinel1_all_df.shape)\n      \n\n  print(sentinel1_all_df.shape)\n  sentinel1_all_df.to_csv(all_sentinel1_file)\n\ndef prepare_training_csv():\n  \"\"\"\n  MOD model:\n    input columns: [m, doy, ndsi]\n    output column: [swe]\n  Sentinel1 model:\n    input columns: [m, doy, grd]\n    output column: [swe]\n  \"\"\"\n  all_mod_file = f\"{github_dir}/data/ready_for_training/modis_all.csv\"\n  modis_all_pd = pd.read_csv(all_mod_file, header=0)\n  print(\"modis_all_size: \", modis_all_pd.shape)\n  print(\"station size: \", station_cell_mapper_pd.shape)\n  print(\"training_feature_pd size: \", training_feature_pd.shape)\n  print(\"testing_feature_pd size: \", testing_feature_pd.shape)\n  \n  ndsi_training_pd = pd.DataFrame(columns=[\"year\", \"m\", \"doy\", \"ndsi\", \"swe\"])\n  modis_all_pd = modis_all_pd.reset_index()\n  for index, row in modis_all_pd.iterrows():\n    dt = datetime.strptime(row['date'], '%Y-%m-%d')\n    month = dt.month\n    year = dt.year\n    doy = dt.timetuple().tm_yday\n    for i in range(3,len(row.index)):\n      cell_id = row.index[i][:-2]\n      ndsi = row.values[i]\n      if cell_id in train_labels_pd.index and row['date'] in train_labels_pd:\n        swe = train_labels_pd.loc[cell_id, row['date']]\n        if not np.isnan(swe):\n          ndsi_training_pd.loc[len(ndsi_training_pd.index)] = [year, month, doy, ndsi, swe]\n  \n  print(ndsi_training_pd.shape)\n  ndsi_training_pd.to_csv(f\"{github_dir}/data/ready_for_training/modis_ready.csv\")\n  \n  all_sentinel1_file = f\"{github_dir}/data/ready_for_training/sentinel1_all.csv\"\n  sentinel1_all_pd = pd.read_csv(all_sentinel1_file, header=0)\n  grd_all_pd = pd.DataFrame(columns=[\"year\", \"m\", \"doy\", \"grd\", \"swe\"])\n  grd_all_pd = grd_all_pd.reset_index()\n  for index, row in sentinel1_all_pd.iterrows():\n    dt = datetime.strptime(row['date'], '%Y-%m-%d')\n    year = dt.year\n    month = dt.month\n    doy = dt.timetuple().tm_yday\n    for i in range(3,len(row.index)):\n      cell_id = row.index[i]\n      grd = row.values[i]\n      if not np.isnan(grd) and cell_id in train_labels_pd.index and row['date'] in train_labels_pd:\n        swe = train_labels_pd.loc[cell_id, row['date']]\n        if not np.isnan(swe):\n          print([month, doy, grd, swe])\n          grd_all_pd = grd_all_pd.append({\"year\": year, \"m\":month, \"doy\": doy, \"grd\": grd, \"swe\": swe}, ignore_index = True)\n  \n  print(grd_all_pd.shape)\n  grd_all_pd.to_csv(f\"{github_dir}/data/ready_for_training/sentinel1_ready.csv\")\n  \n  \nintegrate_modis()\nintegrate_sentinel1()\nprepare_training_csv()\n\n\n  \n  \n  \n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "2wkl6e",
  "name" : "service_deployment",
  "description" : "python",
  "code" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "i2fynz",
  "name" : "service_prediction",
  "description" : null,
  "code" : "# Predict results using the model\n\nfrom sklearn.ensemble import RandomForestRegressor\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn import metrics \nfrom sklearn import tree\nimport joblib\nimport os\nfrom pathlib import Path\nimport json\nimport geopandas as gpd\nimport geojson\nimport os.path\nimport math\nfrom sklearn.model_selection import RandomizedSearchCV\n\n# read the grid geometry file\n\n\n# read the grid geometry file\nhomedir = os.path.expanduser('~')\nprint(homedir)\ngithub_dir = f\"{homedir}/Documents/GitHub/SnowCast\"\nmodis_test_ready_file = f\"{github_dir}/data/ready_for_training/modis_test_ready.csv\"\nmodis_test_ready_pd = pd.read_csv(modis_test_ready_file, header=0, index_col=0)\n\npd_to_clean = modis_test_ready_pd[[\"year\", \"m\", \"doy\", \"ndsi\", \"swe\", \"station_id\", \"cell_id\"]].dropna()\n\nall_features = pd_to_clean[[\"year\", \"m\", \"doy\", \"ndsi\"]].to_numpy()\nall_labels = pd_to_clean[[\"swe\"]].to_numpy().ravel()\n\ndef evaluate(model, test_features, y_test, model_name):\n    y_predicted = model.predict(test_features)\n    mae = metrics.mean_absolute_error(y_test, y_predicted)\n    mse = metrics.mean_squared_error(y_test, y_predicted)\n    r2 = metrics.r2_score(y_test, y_predicted)\n    rmse = math.sqrt(mse)\n\n    print(\"The {} model performance for testing set\".format(model_name))\n    print(\"--------------------------------------\")\n    print('MAE is {}'.format(mae))\n    print('MSE is {}'.format(mse))\n    print('R2 score is {}'.format(r2))\n    print('RMSE is {}'.format(rmse))\n    \n    return y_predicted\n\nbase_model = joblib.load(f\"{homedir}/Documents/GitHub/snowcast_trained_model/model/wormhole_random_forest_basic.joblib\")\nbasic_predicted_values = evaluate(base_model, all_features, all_labels, \"Base Model\")\n\nbest_random = joblib.load(f\"{homedir}/Documents/GitHub/snowcast_trained_model/model/wormhole_random_forest.joblib\")\nrandom_predicted_values = evaluate(best_random, all_features, all_labels, \"Optimized\")\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "e8k4wq",
  "name" : "model_train_validate",
  "description" : null,
  "code" : "# Train Model\n\nprint(\"Train Models\")\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "h1qp9v",
  "name" : "model_test",
  "description" : null,
  "code" : "# Test models\n\n# Random Forest model creation and save to file\n\nfrom sklearn.ensemble import RandomForestRegressor\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn import metrics \nfrom sklearn import tree\nimport joblib\nimport os\nfrom pathlib import Path\nimport json\nimport geopandas as gpd\nimport geojson\nimport os.path\nimport math\nfrom sklearn.model_selection import RandomizedSearchCV\n\n\n# read the grid geometry file\nhomedir = os.path.expanduser('~')\nprint(homedir)\ngithub_dir = f\"{homedir}/Documents/GitHub/SnowCast\"\nmodis_test_ready_file = f\"{github_dir}/data/ready_for_training/modis_train_ready.csv\"\nmodis_test_ready_pd = pd.read_csv(modis_test_ready_file, header=0, index_col=0)\n\npd_to_clean = modis_test_ready_pd[[\"year\", \"m\", \"doy\", \"ndsi\", \"swe\"]].dropna()\n\nall_features = pd_to_clean[[\"year\", \"m\", \"doy\", \"ndsi\"]].to_numpy()\nall_labels = pd_to_clean[[\"swe\"]].to_numpy().ravel()\n\ndef evaluate(model, test_features, y_test, model_name):\n    y_predicted = model.predict(test_features)\n    mae = metrics.mean_absolute_error(y_test, y_predicted)\n    mse = metrics.mean_squared_error(y_test, y_predicted)\n    r2 = metrics.r2_score(y_test, y_predicted)\n    rmse = math.sqrt(mse)\n\n    print(\"The {} model performance for testing set\".format(model_name))\n    print(\"--------------------------------------\")\n    print('MAE is {}'.format(mae))\n    print('MSE is {}'.format(mse))\n    print('R2 score is {}'.format(r2))\n    print('RMSE is {}'.format(rmse))\n    \n    return y_predicted\n\n#base_model = joblib.load(f\"{homedir}/Documents/GitHub/snowcast_trained_model/model/wormhole_random_forest_basic_v2.joblib\")\nbase_model = joblib.load(f\"{homedir}/Documents/GitHub/snowcast_trained_model/model/wormhole_random_forest_basic_v2.joblib\")\nbase_accuracy = evaluate(base_model, all_features, all_labels, \"Base Model\")\n\nbest_random = joblib.load(f\"{homedir}/Documents/GitHub/snowcast_trained_model/model/wormhole_random_forest_v2.joblib\")\nrandom_accuracy = evaluate(best_random, all_features, all_labels, \"Optimized\")\n\n\n\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "urd0nk",
  "name" : "data_terrainFeatures",
  "description" : null,
  "code" : "# Load dependencies\nimport geopandas as gpd\nimport json\nimport geojson\nfrom pystac_client import Client\nimport planetary_computer\nimport xarray\nimport rioxarray\nimport xrspatial\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom pyproj import Proj, transform\nimport os\n\nhome_dir = os.path.expanduser('~')\nsnowcast_github_dir = f\"{home_dir}/Documents/GitHub/SnowCast/\"\n\n# user-defined paths for data-access\ndata_dir = f'{snowcast_github_dir}data/station_gridcell/'\ngridcells_file = data_dir+'grid_cells.geojson'\nstations_file = data_dir+'ground_measures_metadata.csv'\ngridcells_outfile = data_dir+'gridcells_terrainData.csv'\nstations_outfile = data_dir+'station_terrainData.csv'\n\n# setup client for handshaking and data-access\nclient = Client.open(\n    \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n    ignore_conformance=True,\n)\n\n# Load metadata\ngridcellsGPD = gpd.read_file(gridcells_file)\ngridcells = geojson.load(open(gridcells_file))\nstations = pd.read_csv(stations_file)\n\n# instantiate output panda dataframes\ndf_gridcells = df = pd.DataFrame(columns=(\"Longitude [deg]\",\"Latitude [deg]\",\n                                          \"Elevation [m]\",\"Aspect [deg]\",\n                                          \"Curvature [ratio]\",\"Slope [deg]\"))\ndf_station = pd.DataFrame(columns=(\"Longitude [deg]\",\"Latitude [deg]\",\n                                   \"Elevation [m]\",\"Elevation_30 [m]\",\"Elevation_1000 [m]\",\n                                   \"Aspect_30 [deg]\",\"Aspect_1000 [deg]\",\n                                   \"Curvature_30 [ratio]\",\"Curvature_1000 [ratio]\",\n                                   \"Slope_30 [deg]\",\"Slope_1000 [deg]\"))\n\n# Calculate gridcell characteristics using Copernicus DEM data\nfor idx,cell in enumerate(gridcells['features']):\n    print(idx)\n    search = client.search(\n        collections=[\"cop-dem-glo-30\"],\n        intersects={\"type\":\"Polygon\", \"coordinates\":cell['geometry']['coordinates']},\n    )\n    items = list(search.get_items())   \n    \n    try:\n        signed_asset = planetary_computer.sign(items[0].assets[\"data\"])\n        data = (\n            xarray.open_rasterio(signed_asset.href)\n            .squeeze()\n            .drop(\"band\")\n            .coarsen({\"y\": 1, \"x\": 1})\n            .mean()\n        )\n        cropped_data = data.rio.clip(gridcellsGPD['geometry'][idx:idx+1])\n    except:\n      \tprint(\"fail to open data using xarray\")\n      \t\"\"\"\n        signed_asset = planetary_computer.sign(items[1].assets[\"data\"])\n        data = (\n            xarray.open_rasterio(signed_asset.href)\n            .squeeze()\n            .drop(\"band\")\n            .coarsen({\"y\": 1, \"x\": 1})\n            .mean()\n        )\n        cropped_data = data.rio.clip(gridcellsGPD['geometry'][idx:idx+1])\n        \"\"\"\n    \n    longitude = np.unique(np.ravel(cell['geometry']['coordinates'])[0::2]).mean()\n    latitude = np.unique(np.ravel(cell['geometry']['coordinates'])[1::2]).mean()\n    \n    cropped_data = cropped_data.rio.reproject(\"EPSG:32612\")\n        \n    mean_elev = cropped_data.mean().values\n    print(mean_elev)\n    \n    aspect = xrspatial.aspect(cropped_data)\n    aspect_xcomp = np.nansum(np.cos(aspect.values*(np.pi/180)))\n    aspect_ycomp = np.nansum(np.sin(aspect.values*(np.pi/180)))\n    mean_aspect = np.arctan2(aspect_ycomp,aspect_xcomp)*(180/np.pi)\n    if mean_aspect < 0:\n        mean_aspect = 360 + mean_aspect\n    print(mean_aspect)\n    \n    # Positive curvature = upward convex\n    curvature = xrspatial.curvature(cropped_data)\n    mean_curvature = curvature.mean().values\n    print(mean_curvature)\n    \n    slope = xrspatial.slope(cropped_data)\n    mean_slope = slope.mean().values\n    print(mean_slope)\n    \n    df_gridcells.loc[idx] = [longitude,latitude,\n                             mean_elev,mean_aspect,\n                             mean_curvature,mean_slope]\n    \n    if idx % 250 == 0:\n        df_gridcells.set_index(gridcellsGPD['cell_id'][0:idx+1],inplace=True)\n        df_gridcells.to_csv(gridcells_outfile)\n\n# Save output data into csv format\ndf_gridcells.set_index(gridcellsGPD['cell_id'][0:idx+1],inplace=True)\ndf_gridcells.to_csv(gridcells_outfile)\n\n# Calculate terrain characteristics of stations, and surrounding regions using COP 30\nfor idx,station in stations.iterrows():\n    search = client.search(\n        collections=[\"cop-dem-glo-30\"],\n        intersects={\"type\":\"Point\", \"coordinates\":[station['longitude'],station['latitude']]},\n    )\n    items = list(search.get_items())\n    print(f\"Returned {len(items)} items\")\n    \n    try:\n        signed_asset = planetary_computer.sign(items[0].assets[\"data\"])\n        data = (\n            xarray.open_rasterio(signed_asset.href)\n            .squeeze()\n            .drop(\"band\")\n            .coarsen({\"y\": 1, \"x\": 1})\n            .mean()\n        )\n        xdiff = np.abs(data.x-station['longitude'])\n        ydiff = np.abs(data.y-station['latitude'])\n        xdiff = np.where(xdiff == xdiff.min())[0][0]\n        ydiff = np.where(ydiff == ydiff.min())[0][0]\n        data = data[ydiff-33:ydiff+33,xdiff-33:xdiff+33].rio.reproject(\"EPSG:32612\")\n    except:\n        print(\"Fail to open data using xarray\")\n        \"\"\"\n        signed_asset = planetary_computer.sign(items[1].assets[\"data\"])\n        data = (\n            xarray.open_rasterio(signed_asset.href)\n            .squeeze()\n            .drop(\"band\")\n            .coarsen({\"y\": 1, \"x\": 1})\n            .mean()\n        )\n        xdiff = np.abs(data.x-station['longitude'])\n        ydiff = np.abs(data.y-station['latitude'])\n        xdiff = np.where(xdiff == xdiff.min())[0][0]\n        ydiff = np.where(ydiff == ydiff.min())[0][0]\n        data = data[ydiff-33:ydiff+33,xdiff-33:xdiff+33].rio.reproject(\"EPSG:32612\")\n    \t\"\"\"\n    \n    inProj = Proj(init='epsg:4326')\n    outProj = Proj(init='epsg:32612')\n    new_x,new_y = transform(inProj,outProj,station['longitude'],station['latitude'])\n    \n    mean_elevation = data.mean().values\n    elevation = data.sel(x=new_x,y=new_y,method='nearest')\n    print(elevation.values)\n    \n    aspect = xrspatial.aspect(data)\n    aspect_xcomp = np.nansum(np.cos(aspect.values*(np.pi/180)))\n    aspect_ycomp = np.nansum(np.sin(aspect.values*(np.pi/180)))\n    mean_aspect = np.arctan2(aspect_ycomp,aspect_xcomp)*(180/np.pi)\n    if mean_aspect < 0:\n        mean_aspect = 360 + mean_aspect\n    print(mean_aspect)\n    aspect = aspect.sel(x=new_x,y=new_y,method='nearest')\n    print(aspect.values)\n    \n    # Positive curvature = upward convex\n    curvature = xrspatial.curvature(data)\n    mean_curvature = curvature.mean().values\n    curvature = curvature.sel(x=new_x,y=new_y,method='nearest')\n    print(curvature.values)\n    \n    slope = xrspatial.slope(data)\n    mean_slope = slope.mean().values\n    slope = slope.sel(x=new_x,y=new_y,method='nearest')\n    print(slope.values)\n    \n    df_station.loc[idx] = [station['longitude'],station['latitude'],\n                           station['elevation_m'],elevation.values,mean_elevation,\n                           aspect.values,mean_aspect,\n                           curvature.values,mean_curvature,\n                           slope.values,mean_slope]\n    \n    if idx % 250 == 0:\n        df_station.set_index(stations['station_id'][0:idx+1],inplace=True)\n        df_station.to_csv(stations_outfile)\n\n# Save output data into CSV format\ndf_station.set_index(stations['station_id'][0:idx+1],inplace=True)\ndf_station.to_csv(stations_outfile)\n\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
}]
